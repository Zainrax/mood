//! Mood system for Moodels - defines different emotional states and conversion logic.

use avian2d::prelude::*;
use bevy::prelude::*;
use rand::Rng;
use std::collections::HashMap;

use crate::demo::ai::{AiAction, AiConfig, AiEntity, AiMagnetism, AiWanderState};
use crate::demo::movement::{MovementController, MovementSmoothing, PlayAreaBounded};
use crate::{AppSystems, PausableSystems, asset_tracking::LoadResource};

/// Macro to define mood interactions in a clear, non-repetitive, and correct way.
///
/// This macro generates the `get_mood_interaction` function. It takes rules
/// organized into blocks for maximum clarity and correctness:
///
/// - `one_way`: Defines an asymmetrical rule. `(A, B) => (C, D)` will automatically
///   generate the reverse interaction: `(B, A) => (D, C)`. Use this when one
///   mood "acts on" another.
///
/// - `two_way`: Defines a symmetrical rule for two *different* moods.
///   `(A, B) => (C, D)` generates rules for both `(A, B)` and `(B, A)` to
///   produce the same result `(C, D)`. This is for interactions where the
///   outcome is the same regardless of order.
///
/// - `self_interaction`: Defines rules for when a mood interacts with itself.
///   A rule like `(Rage) => (Rage)` expands to `(Rage, Rage) => (Rage, Rage)`.
///   This prevents duplicate match arms that would otherwise be generated.
///
/// - `neutral_case`: A block to handle the special `(Neutral, Neutral)` interaction.
macro_rules! define_get_mood_interaction {
    (
        $mood_enum:path;
        one_way { $( ($m1a:ident, $m2a:ident) => ($r1a:ident, $r2a:ident) ),* $(,)? }
        two_way { $( ($m1s:ident, $m2s:ident) => ($r1s:ident, $r2s:ident) ),* $(,)? }
        self_interaction { $( ($m_self:ident) => ($r_self:ident) ),* $(,)? }
        neutral_case $neutral_block:block
    ) => {
        /// Determines how two moods interact when they collide.
        /// Generated by the `define_get_mood_interaction!` macro.
        fn get_mood_interaction(mood1: $mood_enum, mood2: $mood_enum) -> ($mood_enum, $mood_enum) {
            use $mood_enum::*;
            // rand::Rng is already in scope from the top of the file via `use rand::Rng;`

            match (mood1, mood2) {
                // Expand `one_way` rules: (A, B) => (C, D) also creates (B, A) => (D, C)
                $(
                    ($m1a, $m2a) => ($r1a, $r2a),
                    ($m2a, $m1a) => ($r2a, $r1a),
                )*

                // Expand `two_way` rules: (A, B) => (C, D) creates both directions.
                $(
                    ($m1s, $m2s) => ($r1s, $r2s),
                    ($m2s, $m1s) => ($r1s, $r2s),
                )*

                // Expand `self_interaction` rules: (A) => (B) becomes (A, A) => (B, B)
                $(
                    ($m_self, $m_self) => ($r_self, $r_self),
                )*

                // The special case for two Neutral Moodels colliding
                (Neutral, Neutral) => $neutral_block,
            }
        }
    };
}
pub(super) fn plugin(app: &mut App) {
    app.register_type::<Mood>();
    app.register_type::<MoodAssets>();
    app.register_type::<MoodObject>();
    app.load_resource::<MoodAssets>();
    app.init_resource::<MoodStatsTimer>();

    // Mood conversion systems
    app.add_systems(
        Update,
        (
            handle_collision_events,
            handle_mood_object_collisions,
            handle_isolation_decay,
            log_mood_statistics,
            // update_mood_natural_progression, // Disabled cyclical progression
        )
            .in_set(AppSystems::Update)
            .in_set(PausableSystems),
    );
}

/// The different emotional states a Moodel can have
#[derive(Component, Debug, Clone, Copy, PartialEq, Eq, Hash, Reflect, serde::Serialize, serde::Deserialize)]
#[reflect(Component)]
pub enum Mood {
    Neutral,
    Calm,
    Happy,
    Rage,
    Sad,
}

impl Mood {
    /// Get the movement speed multiplier for this mood
    pub fn speed_multiplier(self) -> f32 {
        match self {
            Mood::Neutral => 0.75, // 150 units/second baseline
            Mood::Calm => 0.5,     // 100 units/second baseline
            Mood::Happy => 1.0,    // 200 units/second baseline
            Mood::Rage => 1.5,     // 300 units/second baseline
            Mood::Sad => 0.375,    // 75 units/second baseline
        }
    }

    /// Get the color associated with this mood
    pub fn color(self) -> Color {
        match self {
            Mood::Neutral => Color::srgb(0.8, 0.8, 0.8), // Gray
            Mood::Calm => Color::srgb(0.3, 0.6, 1.0),    // Blue
            Mood::Happy => Color::srgb(1.0, 0.9, 0.2),   // Yellow
            Mood::Rage => Color::srgb(1.0, 0.2, 0.2),    // Red
            Mood::Sad => Color::srgb(0.6, 0.4, 0.8),     // Purple
        }
    }
}

/// Resource containing all mood-related assets
#[derive(Resource, Asset, Clone, Reflect)]
#[reflect(Resource)]
pub struct MoodAssets {
    #[dependency]
    pub neutral: Handle<Image>,
    #[dependency]
    pub calm: Handle<Image>,
    #[dependency]
    pub happy: Handle<Image>,
    #[dependency]
    pub rage: Handle<Image>,
    #[dependency]
    pub sad: Handle<Image>,
}

impl MoodAssets {
    /// Get the sprite handle for a specific mood
    pub fn get_sprite(&self, mood: Mood) -> Handle<Image> {
        match mood {
            Mood::Neutral => self.neutral.clone(),
            Mood::Calm => self.calm.clone(),
            Mood::Happy => self.happy.clone(),
            Mood::Rage => self.rage.clone(),
            Mood::Sad => self.sad.clone(),
        }
    }
}

impl FromWorld for MoodAssets {
    fn from_world(world: &mut World) -> Self {
        let assets = world.resource::<AssetServer>();
        Self {
            neutral: assets.load("images/Moodel.png"), // Base sprite for Neutral
            calm: assets.load("images/MoodelCalm.png"),
            happy: assets.load("images/MoodelHappy.png"),
            rage: assets.load("images/MoodelRage.png"),
            sad: assets.load("images/MoodelSad.png"),
        }
    }
}

/// Component for entities that can change moods
#[derive(Component, Debug, Clone, Reflect)]
#[reflect(Component)]
pub struct MoodEntity {
    /// Timer for checking isolation decay
    pub isolation_timer: Timer,
    /// How long the current mood has been stable (for permanence)
    pub mood_stability: f32,
    /// Last time this entity had a social interaction
    pub last_interaction_time: f32,
}

impl Default for MoodEntity {
    fn default() -> Self {
        Self {
            isolation_timer: Timer::from_seconds(3.0, TimerMode::Repeating), // Check for isolation every 3 seconds
            mood_stability: 0.0,
            last_interaction_time: 0.0, // Will be set to current time when entity spawns
        }
    }
}

/// Resource for tracking mood statistics logging
#[derive(Resource)]
pub struct MoodStatsTimer {
    timer: Timer,
}

impl Default for MoodStatsTimer {
    fn default() -> Self {
        Self {
            timer: Timer::from_seconds(5.0, TimerMode::Repeating), // Log every 5 seconds
        }
    }
}

// Determines how two moods interact when they collide
define_get_mood_interaction! {
    Mood; // The enum we are working with

    // Asymmetrical rules: (A, B) => (C, D) will also create (B, A) => (D, C).
    one_way {
        (Rage, Calm) => (Rage, Sad),     // Rage cools to Sad; Calm is unaffected.
        (Rage, Happy) => (Rage, Sad),   // Rage cools to Sad; Happy is unaffected.
        (Rage, Neutral) => (Rage, Rage),  // Rage makes Neutral Sad; Rage is unaffected.
        (Rage, Sad) => (Rage, Sad),
    }

    // Symmetrical rules for two DIFFERENT moods. Both (A, B) and (B, A) give the same result.
    two_way {
        // Rage interactions

        // Happy interactions
        (Happy, Sad) => (Happy, Calm),     // Happy cheers Sad up to Calm.
        (Happy, Calm) => (Happy, Happy),   // Happy spreads to Calm.
        (Happy, Neutral) => (Happy, Calm), // Happy lifts Neutral to Calm.

        // Calm interactions
        (Calm, Sad) => (Calm, Calm),     // Calm soothes Sad to Calm.
        (Calm, Neutral) => (Calm, Calm), // Calm influences Neutral.

        // Sad interactions
        (Sad, Neutral) => (Sad, Sad),     // Sad spreads to Neutral.
    }

    // Symmetrical rules for a mood interacting with itself.
    self_interaction {
        (Rage) => (Rage),
        (Happy) => (Happy),
        (Calm) => (Calm),
        (Sad) => (Sad),
    }

    // Special case for Neutral <-> Neutral, which has random outcomes.
    neutral_case {
        let mut rng = rand::rng(); // Use thread_rng for one-off uses
        match rng.random_range(0..100u8) {
            r if r < 15 => (Sad, Sad),     // 15% Sad + Sad
            r if r < 30 => (Rage, Rage),   // 15% Rage + Rage
            r if r < 65 => (Happy, Happy), // 35% Happy + Happy
            _ => (Calm, Calm),             // 35% Calm + Calm
        }
    }
}

/// Updates mood for a single entity
fn update_entity_mood(
    entity: Entity,
    mood: &mut Mood,
    mood_entity: &mut MoodEntity,
    sprite: &mut Sprite,
    mood_assets: &MoodAssets,
    new_mood: Mood,
) {
    if new_mood != *mood {
        *mood = new_mood;
        sprite.image = mood_assets.get_sprite(new_mood);
        sprite.color = new_mood.color();
        mood_entity.mood_stability = 0.0; // Reset stability on change

        #[cfg(feature = "dev")]
        info!(
            "Entity {:?} mood changed to {:?} through interaction",
            entity, new_mood
        );
    }
}

/// Handle collision events for mood-based social interactions
fn handle_collision_events(
    mut collision_started: EventReader<CollisionStarted>,
    // The query now needs AiWanderState to check for charging and update the hit count
    mut moodel_query: Query<
        (&mut Mood, &mut MoodEntity, &mut Sprite, &mut AiWanderState),
        With<AiEntity>,
    >,
    // We get AiConfig as a resource
    config: Res<AiConfig>,
    mood_assets: Option<Res<MoodAssets>>,
    time: Res<Time>,
) -> Result {
    // Early return if assets aren't loaded yet
    let Some(mood_assets) = mood_assets else {
        return Ok(());
    };

    let current_time = time.elapsed_secs();

    // Handle collision started events - this is where social interactions happen
    for CollisionStarted(entity1, entity2) in collision_started.read() {
        // Use a let-chain for clarity if your Rust version supports it,
        // otherwise nest the `if let`.
        if let (Ok(_moodel1), Ok(_moodel2)) =
            (moodel_query.get(*entity1), moodel_query.get(*entity2))
        {
            // --- NEW: Handle Rage Burnout ---
            let mut process_burnout = |charger_entity: Entity, _target_entity: Entity| {
                if let Ok((mood, _, _, mut wander_state)) = moodel_query.get_mut(charger_entity) {
                    if *mood == Mood::Rage
                        && matches!(wander_state.action, AiAction::Charging { .. })
                    {
                        wander_state.charge_hit_count += 1;
                        info!(
                            "Rage Moodel {:?} hit count: {}",
                            charger_entity, wander_state.charge_hit_count
                        );
                        if wander_state.charge_hit_count >= config.rage_max_hits_before_burnout {
                            info!(
                                "Rage Moodel {:?} burned out! Becoming Calm.",
                                charger_entity
                            );
                            if let Ok((mut mood, mut mood_entity, mut sprite, mut wander_state)) =
                                moodel_query.get_mut(charger_entity)
                            {
                                // Become calm and reset state
                                update_entity_mood(
                                    charger_entity,
                                    &mut mood,
                                    &mut mood_entity,
                                    &mut sprite,
                                    &mood_assets,
                                    Mood::Calm,
                                );
                                wander_state.action = AiAction::Wandering;
                                wander_state.charge_hit_count = 0;
                            }
                        }
                    }
                }
            };

            process_burnout(*entity1, *entity2);
            process_burnout(*entity2, *entity1);
            // --- End of Burnout Logic ---

            // Regular mood interaction logic
            let (mood1, _, _, _) = moodel_query.get(*entity1).unwrap();
            let (mood2, _, _, _) = moodel_query.get(*entity2).unwrap();
            let (new_mood1, new_mood2) = get_mood_interaction(*mood1, *mood2);

            #[cfg(feature = "dev")]
            info!(
                "Mood interaction: {:?} + {:?} → {:?} + {:?}",
                mood1, mood2, new_mood1, new_mood2
            );

            if let Ok((mut mood, mut mood_entity, mut sprite, _)) = moodel_query.get_mut(*entity1) {
                mood_entity.last_interaction_time = current_time;
                update_entity_mood(
                    *entity1,
                    &mut mood,
                    &mut mood_entity,
                    &mut sprite,
                    &mood_assets,
                    new_mood1,
                );
            }
            if let Ok((mut mood, mut mood_entity, mut sprite, _)) = moodel_query.get_mut(*entity2) {
                mood_entity.last_interaction_time = current_time;
                update_entity_mood(
                    *entity2,
                    &mut mood,
                    &mut mood_entity,
                    &mut sprite,
                    &mood_assets,
                    new_mood2,
                );
            }
        }
    }

    Ok(())
}

/// Handle collisions between Moodels and mood-changing objects
fn handle_mood_object_collisions(
    mut collision_started: EventReader<CollisionStarted>,
    mut moodel_query: Query<(&mut Mood, &mut MoodEntity, &mut Sprite), With<AiEntity>>,
    mut mood_object_query: Query<&mut MoodObject>,
    mood_assets: Option<Res<MoodAssets>>,
    time: Res<Time>,
) -> Result {
    // Early return if assets aren't loaded yet
    let Some(mood_assets) = mood_assets else {
        return Ok(());
    };

    let current_time = time.elapsed_secs();

    // Handle collision started events between Moodels and MoodObjects
    for CollisionStarted(entity1, entity2) in collision_started.read() {
        // Check if one entity is a Moodel and the other is a MoodObject
        let moodel_entity;
        let mood_object_entity;

        if moodel_query.contains(*entity1) && mood_object_query.contains(*entity2) {
            moodel_entity = *entity1;
            mood_object_entity = *entity2;
        } else if moodel_query.contains(*entity2) && mood_object_query.contains(*entity1) {
            moodel_entity = *entity2;
            mood_object_entity = *entity1;
        } else {
            continue; // Not a Moodel-MoodObject collision
        }

        // Get the mood object and check cooldown
        if let Ok(mut mood_object) = mood_object_query.get_mut(mood_object_entity) {
            if mood_object.can_affect(moodel_entity, current_time) {
                // Apply mood change to the Moodel
                if let Ok((mut mood, mut mood_entity, mut sprite)) =
                    moodel_query.get_mut(moodel_entity)
                {
                    let target_mood = mood_object.target_mood;

                    if *mood != target_mood {
                        update_entity_mood(
                            moodel_entity,
                            &mut mood,
                            &mut mood_entity,
                            &mut sprite,
                            &mood_assets,
                            target_mood,
                        );

                        // Update interaction time and record hit
                        mood_entity.last_interaction_time = current_time;
                        mood_object.record_hit(moodel_entity, current_time);

                        #[cfg(feature = "dev")]
                        info!(
                            "MoodObject collision: Entity {:?} changed to {:?} by mood object",
                            moodel_entity, target_mood
                        );
                    }
                }
            }
        }
    }

    Ok(())
}

/// Handle isolation decay - Moodels become calm then neutral when isolated
fn handle_isolation_decay(
    time: Res<Time>,
    mood_assets: Option<Res<MoodAssets>>,
    mut moodel_query: Query<(Entity, &mut Mood, &mut MoodEntity, &mut Sprite), With<AiEntity>>,
) -> Result {
    // Early return if assets aren't loaded yet
    let Some(mood_assets) = mood_assets else {
        return Ok(());
    };

    let current_time = time.elapsed_secs();
    let delta = time.delta_secs();

    for (entity, mut mood, mut mood_entity, mut sprite) in &mut moodel_query {
        mood_entity.isolation_timer.tick(time.delta());
        mood_entity.mood_stability += delta; // Track how long mood has been stable

        // Check if entity has been isolated (no interactions for a while)
        if mood_entity.isolation_timer.just_finished() {
            let time_since_interaction = current_time - mood_entity.last_interaction_time;
            let mut rng = rand::rng(); // Use thread_rng for one-off uses

            // If isolated for more than 5 seconds (matching spec), start mood decay toward neutral
            if (time_since_interaction > 2.0 && *mood != Mood::Rage) || time_since_interaction > 6.0
            {
                let new_mood = match *mood {
                    Mood::Rage => Mood::Calm,   // Rage cools to Neutral
                    Mood::Happy => Mood::Calm,  // Happiness fades to Neutral
                    Mood::Sad => Mood::Neutral, // Sadness lifts to Neutral
                    Mood::Calm => match rng.random_bool(1. / 2.) {
                        // equal chance to change to be happy or neutral
                        true => Mood::Happy,    // 50% chance to become Happy
                        false => Mood::Neutral, // 50% chance to become Neutral
                    },
                    Mood::Neutral => match rng.random_range(0..100u8) {
                        // equal chance to change to any mood
                        r if r < 20 => Mood::Happy, // 20% chance to become Happy
                        r if r < 40 => Mood::Sad,   // 20% chance to become Sad
                        r if r < 60 => Mood::Rage,  // 20% chance to become Rage
                        r if r < 80 => Mood::Calm,  // 20% chance to become Calm
                        _ => Mood::Neutral,         // Otherwise stay Neutral
                    },
                };

                if new_mood != *mood {
                    update_entity_mood(
                        entity,
                        &mut mood,
                        &mut mood_entity,
                        &mut sprite,
                        &mood_assets,
                        new_mood,
                    );

                    #[cfg(feature = "dev")]
                    info!(
                        "Entity {:?} isolated decay: {:?} -> {:?}",
                        entity, *mood, new_mood
                    );
                }
            }
        }
    }
    Ok(())
}

// Cyclical progression system disabled - only isolation decay and social interactions now determine mood changes

/// Log mood statistics every 5 seconds
fn log_mood_statistics(
    time: Res<Time>,
    mut stats_timer: ResMut<MoodStatsTimer>,
    moodel_query: Query<&Mood, With<AiEntity>>,
) -> Result {
    stats_timer.timer.tick(time.delta());

    if stats_timer.timer.just_finished() {
        let mut mood_counts = [0; 5]; // [Neutral, Calm, Happy, Rage, Sad]
        let mut total_count = 0;

        // Count each mood type
        for mood in &moodel_query {
            total_count += 1;
            match *mood {
                Mood::Neutral => mood_counts[0] += 1,
                Mood::Calm => mood_counts[1] += 1,
                Mood::Happy => mood_counts[2] += 1,
                Mood::Rage => mood_counts[3] += 1,
                Mood::Sad => mood_counts[4] += 1,
            }
        }

        if total_count > 0 {
            // Calculate percentages
            let neutral_pct = (mood_counts[0] as f32 / total_count as f32) * 100.0;
            let calm_pct = (mood_counts[1] as f32 / total_count as f32) * 100.0;
            let happy_pct = (mood_counts[2] as f32 / total_count as f32) * 100.0;
            let rage_pct = (mood_counts[3] as f32 / total_count as f32) * 100.0;
            let sad_pct = (mood_counts[4] as f32 / total_count as f32) * 100.0;

            info!(
                "MOOD STATS | Total: {} | Neutral: {:.1}% | Calm: {:.1}% | Happy: {:.1}% | Rage: {:.1}% | Sad: {:.1}%",
                total_count, neutral_pct, calm_pct, happy_pct, rage_pct, sad_pct
            );
        }
    }

    Ok(())
}

/// Component for static objects that change mood when collided with
#[derive(Component, Debug, Clone, Reflect)]
#[reflect(Component)]
pub struct MoodObject {
    /// What mood this object triggers when hit
    pub target_mood: Mood,
    /// How long before this object can affect the same entity again (cooldown in seconds)
    pub cooldown: f32,
    /// Track which entities have recently been affected
    pub recent_hits: HashMap<Entity, f32>,
}

impl MoodObject {
    pub fn new(target_mood: Mood, cooldown: f32) -> Self {
        Self {
            target_mood,
            cooldown,
            recent_hits: HashMap::new(),
        }
    }

    /// Check if an entity can be affected by this object (cooldown expired)
    pub fn can_affect(&self, entity: Entity, current_time: f32) -> bool {
        if let Some(&last_hit_time) = self.recent_hits.get(&entity) {
            current_time - last_hit_time >= self.cooldown
        } else {
            true // First time hitting this object
        }
    }

    /// Record that this entity was affected at the current time
    pub fn record_hit(&mut self, entity: Entity, current_time: f32) {
        self.recent_hits.insert(entity, current_time);
    }
}

/// Bundle for a Moodel entity
#[derive(Bundle)]
pub struct MoodelBundle {
    pub name: Name,
    pub ai_entity: AiEntity,
    pub mood: Mood,
    pub mood_entity: MoodEntity,
    pub sprite: Sprite,
    pub transform: Transform,
    pub movement_controller: MovementController,
    pub play_area_bounded: PlayAreaBounded,
    pub movement_smoothing: MovementSmoothing,
    pub rigid_body: RigidBody,
    pub collider: Collider,
    pub linear_velocity: LinearVelocity,
    pub angular_velocity: AngularVelocity,
    pub collision_layers: CollisionLayers,
    pub collision_events: CollisionEventsEnabled,
    pub restitution: Restitution,
    pub locked_axes: LockedAxes,
    pub mass: Mass,
    pub friction: Friction,
    pub gravity_scale: GravityScale,
    pub external_force: ExternalForce,
}

/// Creates a bundle for spawning a Moodel with a specific mood
pub fn spawn_moodel_bundle(
    mood: Mood,
    mood_assets: &MoodAssets,
    position: Vec3,
    max_speed: f32,
    current_time: f32,
) -> impl Bundle {
    (
        MoodelBundle {
            name: Name::new(format!("{:?} Moodel", mood)),
            ai_entity: AiEntity,
            mood,
            mood_entity: MoodEntity {
                isolation_timer: Timer::from_seconds(3.0, TimerMode::Repeating),
                mood_stability: 0.0,
                last_interaction_time: current_time, // Initialize with current game time
            },
            sprite: Sprite {
                image: mood_assets.get_sprite(mood),
                color: mood.color(),
                custom_size: Some(Vec2::new(134.0, 208.0)),
                ..default()
            },
            transform: Transform::from_translation(position).with_scale(Vec3::splat(0.5)),
            movement_controller: MovementController {
                max_speed: max_speed * mood.speed_multiplier(),
                ..default()
            },
            play_area_bounded: PlayAreaBounded {
                restitution: match mood {
                    Mood::Happy => 0.2, // Happy moodels bounce more
                    Mood::Rage => 0.2,  // Rage moodels have harder bounces
                    Mood::Sad => 0.1,   // Sad moodels barely bounce
                    _ => 0.1,           // Default bounce
                },
            },
            locked_axes: LockedAxes::ROTATION_LOCKED, // Lock rotation for 2D top-down movement
            movement_smoothing: MovementSmoothing {
                acceleration: match mood {
                    Mood::Happy => 1000.0, // Happy accelerates quickly
                    Mood::Rage => 2500.0,  // Rage needs very high acceleration for charging
                    Mood::Calm => 400.0,   // Calm accelerates slowly
                    Mood::Sad => 300.0,    // Sad accelerates very slowly
                    _ => 600.0,
                },
                deceleration: match mood {
                    Mood::Rage => 1500.0,  // Rage needs quick deceleration for charges
                    Mood::Happy => 1200.0, // Happy decelerates quickly
                    Mood::Calm => 1000.0,  // Calm decelerates moderately
                    Mood::Sad => 600.0,    // Sad decelerates slowly
                    _ => 1000.0,
                },
                ..default()
            },
            // Physics components
            rigid_body: RigidBody::Dynamic,
            collider: Collider::circle(50.0), // Larger radius for better collision detection
            linear_velocity: LinearVelocity::default(),
            angular_velocity: AngularVelocity::default(),
            collision_layers: CollisionLayers::default(), // Default collision layers
            collision_events: CollisionEventsEnabled,     // Enable collision events
            restitution: Restitution::new(match mood {
                Mood::Happy => 0.9, // Happy moodels bounce more
                Mood::Rage => 0.7,  // Rage moodels have harder bounces
                Mood::Sad => 0.3,   // Sad moodels barely bounce
                _ => 0.6,           // Default bounce
            }),
            mass: Mass(2.0), // Give Moodels more mass for better collision physics
            friction: Friction::new(0.1), // Light friction so they don't stick together
            gravity_scale: GravityScale(0.0), // No gravity for 2D top-down movement
            external_force: ExternalForce::default(), // For applying movement forces
        },
        // Add the new AI components directly to the entity
        AiWanderState::new(),
        AiMagnetism {
            vision_radius: 250.0,
            cohesion_strength: 0.05,
            separation_strength: 0.1,
            separation_distance: 20.0,
        },
    )
}

/// Creates a mood object bundle with specific shape and properties
pub fn create_mood_object_bundle(
    mood: Mood,
    position: Vec3,
    cooldown: f32,
    meshes: &mut ResMut<Assets<Mesh>>,
    materials: &mut ResMut<Assets<ColorMaterial>>,
) -> impl Bundle {
    let (mesh, color) = match mood {
        Mood::Rage => {
            // Red spiky triangle for rage
            let triangle = Triangle2d::new(
                Vec2::Y * 30.0,          // Top point
                Vec2::new(-25.0, -20.0), // Bottom left
                Vec2::new(25.0, -20.0),  // Bottom right
            );
            (meshes.add(triangle), Color::srgb(0.9, 0.1, 0.1)) // Bright red
        }
        Mood::Sad => {
            // Blue teardrop/circle for sadness
            let circle = Circle::new(25.0);
            (meshes.add(circle), Color::srgb(0.1, 0.3, 0.8)) // Deep blue
        }
        Mood::Happy => {
            // Yellow star shape for happiness
            let star = RegularPolygon::new(25.0, 5);
            (meshes.add(star), Color::srgb(1.0, 0.9, 0.1)) // Bright yellow
        }
        Mood::Calm => {
            // Green smooth circle for calm
            let circle = Circle::new(20.0);
            (meshes.add(circle), Color::srgb(0.2, 0.8, 0.3)) // Soft green
        }
        Mood::Neutral => {
            // Gray square for neutral
            let square = Rectangle::new(30.0, 30.0);
            (meshes.add(square), Color::srgb(0.6, 0.6, 0.6)) // Gray
        }
    };

    (
        Name::new(format!("{:?} Mood Object", mood)),
        MoodObject::new(mood, cooldown),
        Mesh2d(mesh),
        MeshMaterial2d(materials.add(color)),
        Transform::from_translation(position),
        // Physics components for collision detection
        RigidBody::Static,      // Static objects don't move
        Collider::circle(30.0), // Slightly larger than visual for better collision
        CollisionLayers::default(),
        CollisionEventsEnabled,
    )
}
